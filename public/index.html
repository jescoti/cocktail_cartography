<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cocktail Cartography — Clustering Viz</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* ── Art Deco Design System ─────────────────────────────────── */
    /* Color palette inspired by Art Deco: rich blacks, golds, cream, and jewel tones */
    :root {
      --deco-black: #1a1a1d;
      --deco-charcoal: #2d2d30;
      --deco-gold: #D4AF37;
      --deco-gold-dark: #B8941E;
      --deco-cream: #F5F5DC;
      --deco-cream-dark: #E8E8CF;
      --deco-silver: #C0C0C0;
      --deco-emerald: #50C878;
      --deco-sapphire: #0F52BA;
      --deco-ruby: #E0115F;
      --deco-bronze: #CD7F32;
      --text-primary: #F5F5DC;
      --text-secondary: #C5C5B0;
      --text-tertiary: #9A9A88;
      --text-muted: #6B6B60;
      --border-primary: #D4AF37;
      --border-secondary: #4a4a3d;
      --bg-panel: #1a1a1d;
      --bg-panel-lighter: #2d2d30;
    }

    /* ── Reset & base ─────────────────────────────────────────── */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Futura", "Century Gothic", "Avenir Next", "Helvetica Neue", Arial, sans-serif;
      font-size: 13px;
      background: var(--deco-black);
      color: var(--text-primary);
      display: flex;
      height: 100vh;
      overflow: hidden;
      letter-spacing: 0.01em;
    }

    /* ── Art Deco scrollbars ───────────────────────────────────── */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--deco-gold) transparent;
    }
    *::-webkit-scrollbar { width: 8px; }
    *::-webkit-scrollbar-track {
      background: transparent;
    }
    *::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, var(--deco-gold) 0%, var(--deco-gold-dark) 100%);
      border-radius: 4px;
      border: 1px solid var(--deco-charcoal);
    }
    *::-webkit-scrollbar-thumb:hover {
      background: var(--deco-gold);
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.4);
    }

    /* ── Sidebar ──────────────────────────────────────────────── */
    #sidebar {
      width: 280px;
      min-width: 180px;
      max-width: 520px;
      background: var(--bg-panel);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      padding: 20px 18px;
      gap: 24px;
      flex-shrink: 0;
      border-right: 2px solid var(--border-primary);
      position: relative;
    }


    /* ── Resize handle ────────────────────────────────────────── */
    #resize-handle {
      width: 6px;
      background: linear-gradient(180deg, var(--border-secondary) 0%, var(--deco-charcoal) 50%, var(--border-secondary) 100%);
      cursor: col-resize;
      flex-shrink: 0;
      position: relative;
      transition: all 0.2s ease;
      z-index: 10;
      border-left: 1px solid var(--border-secondary);
      border-right: 1px solid var(--border-secondary);
    }
    #resize-handle:hover,
    #resize-handle.dragging {
      background: linear-gradient(180deg, var(--deco-gold) 0%, var(--deco-gold-dark) 50%, var(--deco-gold) 100%);
      box-shadow: 0 0 12px rgba(212, 175, 55, 0.5);
      border-color: var(--deco-gold);
    }
    /* Wider invisible hit area */
    #resize-handle::after {
      content: "";
      position: absolute;
      inset: 0 -6px;
    }

    h1 {
      font-size: 18px;
      font-weight: 300;
      color: var(--deco-cream);
      letter-spacing: 0.15em;
      text-transform: uppercase;
      position: relative;
      padding-bottom: 12px;
      margin-bottom: 4px;
    }
    h1::after {
      content: "";
      position: absolute;
      bottom: 0;
      left: 0;
      width: 60px;
      height: 2px;
      background: linear-gradient(90deg, var(--deco-gold) 0%, transparent 100%);
    }
    h1 span {
      color: var(--deco-gold);
      font-weight: 500;
    }

    .section-label {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--deco-gold);
      margin-bottom: 10px;
      position: relative;
      padding-left: 12px;
    }
    .section-label::before {
      content: "▸";
      position: absolute;
      left: 0;
      color: var(--deco-gold);
    }

    /* Strategy radio group */
    .strategy-btn {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 12px 14px;
      border-radius: 2px;
      cursor: pointer;
      border: 2px solid var(--border-secondary);
      background: var(--bg-panel-lighter);
      transition: all 0.2s ease;
      user-select: none;
      position: relative;
      overflow: hidden;
    }
    .strategy-btn::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: transparent;
      transition: background 0.2s ease;
    }
    .strategy-btn:hover {
      background: var(--deco-charcoal);
      border-color: var(--deco-gold);
      box-shadow: 0 2px 8px rgba(212, 175, 55, 0.2);
    }
    .strategy-btn:hover::before {
      background: var(--deco-gold);
    }
    .strategy-btn.active {
      background: var(--deco-charcoal);
      border-color: var(--deco-gold);
      box-shadow: 0 0 16px rgba(212, 175, 55, 0.3);
    }
    .strategy-btn.active::before {
      background: var(--deco-gold);
    }
    .strategy-btn input { display: none; }
    .strategy-title {
      font-weight: 600;
      color: var(--deco-cream);
      font-size: 12px;
      letter-spacing: 0.05em;
    }
    .strategy-desc {
      font-size: 11px;
      color: var(--text-secondary);
      line-height: 1.5;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 0.3s ease, opacity 0.25s ease, margin 0.3s ease;
      margin-top: 0;
    }
    .strategy-btn.active .strategy-desc {
      max-height: 80px;
      opacity: 1;
      margin-top: 4px;
    }

    /* α/β slider */
    .slider-drawer {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      padding: 0 10px;
      transition: max-height 0.3s ease, opacity 0.25s ease, padding 0.3s ease;
      background: rgba(212, 175, 55, 0.05);
      border-left: 2px solid transparent;
      margin-left: 4px;
    }
    .slider-drawer.open {
      max-height: 90px;
      opacity: 1;
      padding: 12px 10px;
      border-left-color: var(--deco-gold);
    }
    #alpha-labels, #tau-labels {
      display: flex;
      justify-content: space-between;
      font-size: 10px;
      color: var(--text-secondary);
      letter-spacing: 0.03em;
    }
    #alpha-slider-row, #tau-slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #alpha-slider, #tau-slider {
      flex: 1;
      accent-color: var(--deco-gold);
      height: 6px;
    }
    .alpha-step-btn {
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      background: var(--bg-panel-lighter);
      border: 2px solid var(--border-secondary);
      border-radius: 2px;
      color: var(--text-secondary);
      font-size: 14px;
      font-weight: 600;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: all 0.15s ease;
    }
    .alpha-step-btn:hover {
      background: var(--deco-charcoal);
      border-color: var(--deco-gold);
      color: var(--deco-gold);
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
    }
    .alpha-step-btn:active {
      background: var(--deco-gold);
      color: var(--deco-black);
    }
    #alpha-value, #tau-value {
      text-align: center;
      font-size: 11px;
      color: var(--text-secondary);
      margin: 0;
      letter-spacing: 0.03em;
    }

    /* Dropdowns and toggles */
    select {
      width: 100%;
      background: var(--bg-panel-lighter);
      border: 2px solid var(--border-secondary);
      border-radius: 2px;
      color: var(--deco-cream);
      padding: 8px 10px;
      font-size: 12px;
      font-family: inherit;
      letter-spacing: 0.03em;
      cursor: pointer;
      outline: none;
      transition: all 0.2s ease;
    }
    select:hover {
      border-color: var(--deco-gold);
      background: var(--deco-charcoal);
    }
    select:focus {
      border-color: var(--deco-gold);
      box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
    }

    .toggle-row {
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      padding: 4px 0;
      color: var(--text-secondary);
      transition: color 0.2s ease;
    }
    .toggle-row:hover {
      color: var(--deco-cream);
    }
    .toggle-row input[type="checkbox"] {
      accent-color: var(--deco-gold);
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    /* Family checkboxes */
    .family-checks {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .family-checks label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      font-size: 12px;
      color: var(--text-secondary);
      padding: 4px 0;
      transition: color 0.2s ease;
    }
    .family-checks label:hover {
      color: var(--deco-cream);
    }
    .family-checks input[type="checkbox"] {
      accent-color: var(--deco-gold);
      width: 16px;
      height: 16px;
      cursor: pointer;
    }

    /* Explanation panel */
    #explanation {
      background: var(--bg-panel-lighter);
      border: 2px solid var(--border-secondary);
      border-radius: 2px;
      padding: 14px;
      font-size: 11.5px;
      line-height: 1.7;
      color: var(--text-secondary);
      position: relative;
    }
    #explanation::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 3px;
      background: linear-gradient(90deg, var(--deco-gold) 0%, transparent 50%);
    }
    #explanation strong {
      color: var(--deco-cream);
      font-weight: 600;
    }
    #explanation em {
      color: var(--deco-gold);
      font-style: normal;
    }
    #explanation code {
      background: rgba(212, 175, 55, 0.1);
      border: 1px solid rgba(212, 175, 55, 0.2);
      padding: 2px 6px;
      border-radius: 2px;
      font-family: "Monaco", "Courier New", monospace;
      font-size: 10px;
      color: var(--deco-gold);
    }

    /* ── Main area ────────────────────────────────────────────── */
    #main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
      background: var(--deco-black);
    }

    #chart {
      flex: 1;
      position: relative;
    }

    svg#scatter {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* ── Bottom Display Panel ──────────────────────────────────── */
    #bottom-panel {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-panel);
      border-top: 2px solid var(--deco-gold);
      z-index: 50;
      transition: transform 0.3s ease;
    }
    #bottom-panel.collapsed {
      transform: translateY(calc(100% - 32px));
    }
    #bottom-panel-toggle {
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      cursor: pointer;
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--deco-gold);
      user-select: none;
      transition: background 0.2s;
    }
    #bottom-panel-toggle:hover {
      background: var(--bg-panel-lighter);
    }
    #bottom-panel-arrow {
      transition: transform 0.3s ease;
      font-size: 8px;
    }
    #bottom-panel.collapsed #bottom-panel-arrow {
      transform: rotate(0deg);
    }
    #bottom-panel:not(.collapsed) #bottom-panel-arrow {
      transform: rotate(180deg);
    }
    #bottom-panel-content {
      display: flex;
      align-items: flex-start;
      gap: 24px;
      padding: 16px 20px 20px;
      flex-wrap: wrap;
    }
    .bp-section {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .bp-label {
      font-size: 10px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--deco-gold);
    }
    #bottom-panel select {
      width: auto;
      min-width: 140px;
    }
    .bp-checks {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .bp-checks label {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      font-size: 12px;
      color: var(--text-secondary);
    }
    .bp-checks input[type="checkbox"] {
      accent-color: var(--deco-gold);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    /* Dots */
    .dot {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .dot:hover {
      filter: brightness(1.3) drop-shadow(0 0 8px currentColor);
    }
    .dot.dimmed { opacity: 0.12; }

    /* Labels */
    .dot-label {
      font-size: 10px;
      font-weight: 500;
      fill: var(--deco-cream);
      pointer-events: none;
      user-select: none;
      paint-order: stroke fill;
      stroke: var(--deco-black);
      stroke-width: 3.5px;
      stroke-linejoin: round;
      letter-spacing: 0.03em;
      font-family: inherit;
    }
    .dot-label.dimmed { opacity: 0.12; }

    /* Leader lines from label to dot */
    .label-line {
      stroke: var(--border-secondary);
      stroke-width: 1;
      stroke-dasharray: 2, 2;
      pointer-events: none;
      fill: none;
      opacity: 0.6;
    }
    .label-line.dimmed { opacity: 0.08; }

    /* ── Tooltip ──────────────────────────────────────────────── */
    #tooltip {
      position: absolute;
      top: 0; left: 0;
      background: var(--bg-panel);
      border: 3px solid var(--deco-gold);
      border-radius: 0;
      padding: 16px 18px;
      pointer-events: none;
      opacity: 0;
      min-width: 260px;
      max-width: 320px;
      transition: opacity 0.2s ease;
      z-index: 100;
      box-shadow: 0 12px 40px rgba(0,0,0,0.7), 0 0 20px rgba(212, 175, 55, 0.2);
    }
    /* Art Deco corner accents */
    #tooltip::before,
    #tooltip::after {
      content: "";
      position: absolute;
      width: 12px;
      height: 12px;
      border: 2px solid var(--deco-gold);
    }
    #tooltip::before {
      top: -3px;
      left: -3px;
      border-right: none;
      border-bottom: none;
    }
    #tooltip::after {
      bottom: -3px;
      right: -3px;
      border-left: none;
      border-top: none;
    }
    #tooltip.pinned { pointer-events: all; }
    #tooltip.visible { opacity: 1; }

    .tt-name {
      font-size: 15px;
      font-weight: 600;
      color: var(--deco-gold);
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-bottom: 6px;
      border-bottom: 1px solid rgba(212, 175, 55, 0.3);
      padding-bottom: 6px;
    }
    .tt-meta {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      letter-spacing: 0.03em;
    }
    .tt-components {
      font-size: 11.5px;
      line-height: 1.9;
      border-collapse: collapse;
      width: 100%;
      margin-bottom: 12px;
    }
    .tt-components td {
      padding: 2px 6px;
      vertical-align: top;
    }
    .tt-components td:first-child {
      color: var(--deco-cream);
      font-weight: 500;
    }
    .tt-components td:nth-child(2) {
      color: var(--text-tertiary);
      font-size: 10px;
      font-style: italic;
    }
    .tt-components td:last-child {
      color: var(--text-muted);
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .tt-garnish {
      font-size: 11px;
      color: var(--text-secondary);
      margin-bottom: 12px;
      font-style: italic;
    }
    .tt-nn-title {
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--deco-gold);
      margin-bottom: 8px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border-secondary);
    }
    .tt-nn-row {
      display: flex;
      justify-content: space-between;
      font-size: 11px;
      padding: 3px 0;
    }
    .tt-nn-name {
      color: var(--text-secondary);
    }
    .tt-nn-dist {
      color: var(--text-tertiary);
      font-variant-numeric: tabular-nums;
    }
    .tt-close {
      display: block;
      margin-top: 12px;
      text-align: center;
      font-size: 10px;
      color: var(--text-muted);
      cursor: pointer;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      padding: 6px;
      border-top: 1px solid var(--border-secondary);
      transition: color 0.2s ease;
    }
    .tt-close:hover {
      color: var(--deco-gold);
    }

    /* ── Loading overlay ──────────────────────────────────────── */
    #loading {
      position: absolute;
      inset: 0;
      background: var(--deco-black);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 300;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--deco-gold);
      z-index: 200;
    }

    /* ── Right ingredient panel ───────────────────────────────── */
    #ingredient-panel {
      width: 240px;
      min-width: 160px;
      max-width: 400px;
      background: var(--bg-panel);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      flex-shrink: 0;
      border-left: 2px solid var(--border-primary);
      position: relative;
    }
    #ingredient-panel::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(135deg, transparent 25%, var(--deco-gold) 25%, var(--deco-gold) 50%, transparent 50%, transparent 75%, var(--deco-gold) 75%, var(--deco-gold));
      background-size: 8px 8px;
    }
    #ingredient-panel-header {
      padding: 20px 18px 12px;
      flex-shrink: 0;
      border-bottom: 2px solid var(--border-secondary);
    }
    #ingredient-panel-header .section-label {
      margin-bottom: 6px;
    }
    #ingredient-count {
      font-size: 11px;
      color: var(--text-tertiary);
      letter-spacing: 0.03em;
    }
    #ingredient-panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 10px 0;
    }
    /* Ingredient group */
    .ing-group {
      padding: 0 0 6px;
    }
    .ing-group-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 16px 6px;
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }
    .ing-group-header:hover {
      background: var(--bg-panel-lighter);
    }
    .ing-group-title {
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--deco-gold);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .ing-group-chevron {
      font-size: 9px;
      color: var(--deco-gold);
      transition: transform 0.2s ease;
      flex-shrink: 0;
    }
    .ing-group.collapsed .ing-group-chevron { transform: rotate(-90deg); }
    .ing-group-actions {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
    }
    .ing-group-toggle {
      font-size: 9px;
      color: var(--text-tertiary);
      cursor: pointer;
      padding: 2px 6px;
      border-radius: 2px;
      border: 1px solid var(--border-secondary);
      background: transparent;
      transition: all 0.15s ease;
      white-space: nowrap;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .ing-group-toggle:hover {
      color: var(--deco-gold);
      border-color: var(--deco-gold);
      background: rgba(212, 175, 55, 0.1);
    }
    .ing-group-items {
      overflow: hidden;
      padding: 0 16px 4px;
    }
    .ing-group.collapsed .ing-group-items { display: none; }
    .ing-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 3px 0;
      cursor: pointer;
      font-size: 11.5px;
      color: var(--text-secondary);
      line-height: 1.5;
      transition: color 0.2s ease;
    }
    .ing-item:hover {
      color: var(--deco-cream);
    }
    .ing-item input[type="checkbox"] {
      accent-color: var(--deco-gold);
      width: 15px;
      height: 15px;
      flex-shrink: 0;
      cursor: pointer;
    }
    .ing-item.unavailable {
      color: var(--text-muted);
      opacity: 0.5;
    }
    .ing-item.unavailable input { opacity: 0.4; }
    /* Subgroup label (e.g. "Whiskey" inside Spirits) */
    .ing-subgroup-label {
      font-size: 9px;
      font-weight: 700;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-tertiary);
      padding: 8px 0 3px;
      margin-top: 4px;
      border-top: 1px solid rgba(212, 175, 55, 0.15);
    }
    .ing-subgroup-label:first-child {
      border-top: none;
      margin-top: 0;
    }

    /* ── Right resize handle ──────────────────────────────────── */
    #right-resize-handle {
      width: 6px;
      background: linear-gradient(180deg, var(--border-secondary) 0%, var(--deco-charcoal) 50%, var(--border-secondary) 100%);
      cursor: col-resize;
      flex-shrink: 0;
      position: relative;
      transition: all 0.2s ease;
      z-index: 10;
      border-left: 1px solid var(--border-secondary);
      border-right: 1px solid var(--border-secondary);
    }
    #right-resize-handle:hover,
    #right-resize-handle.dragging {
      background: linear-gradient(180deg, var(--deco-gold) 0%, var(--deco-gold-dark) 50%, var(--deco-gold) 100%);
      box-shadow: 0 0 12px rgba(212, 175, 55, 0.5);
      border-color: var(--deco-gold);
    }
    #right-resize-handle::after {
      content: "";
      position: absolute;
      inset: 0 -6px;
    }

    /* Legend */
    #legend {
      position: absolute;
      bottom: 20px;
      right: 20px;
      background: var(--bg-panel);
      border: 2px solid var(--deco-gold);
      border-radius: 0;
      padding: 12px 16px;
      min-width: 140px;
      z-index: 10;
      box-shadow: 0 8px 24px rgba(0,0,0,0.6), 0 0 16px rgba(212, 175, 55, 0.2);
    }
    #legend-title {
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      color: var(--deco-gold);
      margin-bottom: 10px;
      padding-bottom: 6px;
      border-bottom: 1px solid rgba(212, 175, 55, 0.3);
    }
    .legend-row {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 11px;
      color: var(--text-secondary);
      padding: 3px 0;
      letter-spacing: 0.02em;
    }
    .legend-swatch {
      width: 14px;
      height: 14px;
      border-radius: 0;
      flex-shrink: 0;
      border: 1px solid rgba(245, 245, 220, 0.2);
    }
  </style>
</head>
<body>

<!-- ── SIDEBAR ──────────────────────────────────────────────────────────── -->
<div id="sidebar">
  <h1>Cocktail <span>Cartography</span></h1>

  <!-- Strategy selector -->
  <div>
    <div class="section-label">Vectorization Strategy</div>
    <div id="strategy-group" style="display:flex;flex-direction:column;gap:4px;">

      <label class="strategy-btn active" data-strategy="tau">
        <input type="radio" name="strategy" value="tau" checked />
        <span class="strategy-title">Perceptual Blend</span>
        <span class="strategy-desc">Controls how much intense ingredients influence clustering. Slide from punchy-dominates to volume-proportional.</span>
      </label>

      <!-- τ slider — inline after Perceptual Blend -->
      <div id="tau-row" class="slider-drawer open">
        <div id="tau-labels">
          <span>← Intense wins</span>
          <span>By volume →</span>
        </div>
        <div id="tau-slider-row">
          <button class="alpha-step-btn" id="tau-dec" title="Lower tau">‹</button>
          <input id="tau-slider" type="range" min="0" max="24" step="1" value="12">
          <button class="alpha-step-btn" id="tau-inc" title="Higher tau">›</button>
        </div>
        <div id="tau-value">τ = 5.62 (balanced)</div>
      </div>

      <label class="strategy-btn" data-strategy="blend_struct">
        <input type="radio" name="strategy" value="blend_struct" />
        <span class="strategy-title">Taste + Structure</span>
        <span class="strategy-desc">Balances between how a cocktail tastes and how it's constructed. Use the slider to explore.</span>
      </label>

      <!-- α/β slider — inline after Blend+Structure -->
      <div id="alpha-row" class="slider-drawer">
        <div id="alpha-labels">
          <span>← How it's made</span>
          <span>How it tastes →</span>
        </div>
        <div id="alpha-slider-row">
          <button class="alpha-step-btn" id="alpha-dec" title="More structure">‹</button>
          <input id="alpha-slider" type="range" min="0" max="20" step="1" value="10">
          <button class="alpha-step-btn" id="alpha-inc" title="More flavor">›</button>
        </div>
        <div id="alpha-value">α = 0.50 (balanced)</div>
      </div>

      <label class="strategy-btn" data-strategy="role_slot">
        <input type="radio" name="strategy" value="role_slot" />
        <span class="strategy-title">Recipe Grammar</span>
        <span class="strategy-desc">Compares drinks by matching ingredient roles: base-to-base, modifier-to-modifier. Pure structural view.</span>
      </label>

    </div>
  </div>

  <!-- Strategy explanation -->
  <div>
    <div class="section-label">About This View</div>
    <div id="explanation"></div>
  </div>

  <!-- About link -->
  <div style="margin-top: auto; padding-top: 16px; border-top: 1px solid var(--border-secondary);">
    <a href="about.html" id="about-link" style="display: flex; align-items: center; gap: 8px; color: var(--deco-gold); text-decoration: none; font-size: 11px; letter-spacing: 0.08em; text-transform: uppercase; transition: color 0.2s;">
      <span style="font-size: 14px;">?</span> About this project
    </a>
  </div>
</div>

<!-- ── RESIZE HANDLE ─────────────────────────────────────────────────────── -->
<div id="resize-handle"></div>

<!-- ── MAIN CHART ────────────────────────────────────────────────────────── -->
<div id="main">
  <div id="loading">Loading embeddings…</div>
  <div id="chart">
    <svg id="scatter"></svg>
    <div id="tooltip">
      <div class="tt-name" id="tt-name"></div>
      <div class="tt-meta" id="tt-meta"></div>
      <table class="tt-components" id="tt-components"></table>
      <div class="tt-garnish" id="tt-garnish"></div>
      <div class="tt-nn-title">Nearest neighbors</div>
      <div id="tt-neighbors"></div>
      <span class="tt-close" id="tt-close">click to dismiss · esc</span>
    </div>
    <div id="legend">
      <div id="legend-title">Legend</div>
      <div id="legend-items"></div>
    </div>
  </div>

  <!-- ── BOTTOM DISPLAY PANEL ──────────────────────────────────────────── -->
  <div id="bottom-panel" class="collapsed">
    <div id="bottom-panel-toggle">
      <span id="bottom-panel-arrow">&#9650;</span> Display Options
    </div>
    <div id="bottom-panel-content">
      <div class="bp-section">
        <label class="bp-label">Color by</label>
        <select id="color-select">
          <option value="base_spirit">Base spirit</option>
          <option value="family">Family</option>
          <option value="served">Served</option>
          <option value="dominant_flavor">Dominant flavor</option>
          <option value="sweet">Sweetness</option>
          <option value="bitter">Bitterness</option>
          <option value="herbal">Herbaceousness</option>
          <option value="smoke">Smoke</option>
          <option value="citrus_acid">Citrus intensity</option>
        </select>
      </div>
      <div class="bp-section">
        <label class="bp-label">Families</label>
        <div class="bp-checks">
          <label><input type="checkbox" class="family-cb" value="sour" checked> Sour</label>
          <label><input type="checkbox" class="family-cb" value="spirit_forward" checked> Spirit-fwd</label>
          <label><input type="checkbox" class="family-cb" value="built" checked> Built</label>
          <label><input type="checkbox" class="family-cb" value="other" checked> Other</label>
        </div>
      </div>
      <div class="bp-section">
        <label class="bp-label">Display</label>
        <label class="toggle-row">
          <input id="show-labels" type="checkbox">
          <span>Show names</span>
        </label>
      </div>
    </div>
  </div>
</div>

<!-- ── RIGHT RESIZE HANDLE ───────────────────────────────────────────────── -->
<div id="right-resize-handle"></div>

<!-- ── INGREDIENT PANEL ──────────────────────────────────────────────────── -->
<div id="ingredient-panel">
  <div id="ingredient-panel-header">
    <div class="section-label">My Bar</div>
    <div id="ingredient-count">All cocktails shown</div>
  </div>
  <div id="ingredient-panel-body">
    <!-- populated by JS -->
  </div>
</div>

<script>
// ────────────────────────────────────────────────────────────────────────────
// Constants & color scales
// ────────────────────────────────────────────────────────────────────────────

const STRATEGY_EXPLANATIONS = {
  tau: `<strong>Perceptual Blend</strong><br>
Controls how much intense ingredients influence the clustering.
Low τ: a dash of Chartreuse or Fernet dominates a drink's character.
High τ: every ingredient contributes proportionally by volume.<br><br>
<strong>Look for:</strong> At low τ, drinks anchored by a punchy accent cluster together.
At high τ, drinks with similar overall flavor profiles are nearest neighbors.<br><br>
<strong>Tip:</strong> Start in the middle, then slide left to see "punch-driven" groupings
or right for "volume-proportional" ones.`,

  blend_struct: `<strong>Taste + Structure</strong><br>
Balances between how a cocktail <em>tastes</em> and how it's <em>constructed</em>.
Flavor = the 15-dimensional taste profile. Structure = proportions of base, modifier,
citrus, accent, plus serving style.<br><br>
<strong>Look for:</strong> Slide toward "How it tastes" and similar flavors cluster;
slide toward "How it's made" and similar recipes cluster.
Two drinks can taste alike but be built very differently.<br><br>
<strong>Tip:</strong> The sweet spot is often around α = 0.50 (balanced).`,

  role_slot: `<strong>Recipe Grammar</strong><br>
Compares drinks slot-by-slot: base vs. base, modifier vs. modifier, citrus vs. citrus.
Each cocktail becomes a 60-dimensional vector (four 15-dim flavor profiles).<br><br>
<strong>Look for:</strong> A Manhattan and a Bijou are close because their base and
modifier slots are flavor-similar. A Manhattan and a Daiquiri are far apart because
one has no citrus slot, the other has no modifying slot.<br><br>
<strong>Unique:</strong> The only strategy that respects ingredient <em>roles</em>,
not just overall flavor.`
};

const CATEGORICAL_PALETTES = {
  base_spirit: {
    whiskey: "#f97316",
    gin:     "#22d3ee",
    agave:   "#4ade80",
    rum:     "#a78bfa",
    brandy:  "#fb7185",
    vodka:   "#fbbf24",
    mixed:   "#94a3b8",
    other:   "#52525b",
  },
  family: {
    sour:           "#22d3ee",
    spirit_forward: "#f97316",
    built:          "#4ade80",
    other:          "#94a3b8",
  },
  served: {
    up:     "#f97316",
    on_ice: "#22d3ee",
    either: "#a78bfa",
  },
  dominant_flavor: {
    sweet:  "#f97316",
    bitter: "#22d3ee",
    herbal: "#4ade80",
    citrus: "#fbbf24",
    fruit:  "#fb7185",
    spice:  "#a78bfa",
    other:  "#52525b",
  },
};

const SEQUENTIAL_COLOR = d3.scaleSequential(d3.interpolatePlasma).domain([0, 1]);

// 21 steps: 0.00, 0.05, 0.10, … 1.00
const ALPHA_STEPS = Array.from({length: 21}, (_, i) => Math.round(i * 5) / 100);
const ALPHA_KEY_MAP = Object.fromEntries(
  ALPHA_STEPS.map((a, i) => [i, `blend_struct_a${String(Math.round(a * 100)).padStart(3, "0")}`])
);

// Tau values from our generation script (logspace 0.1 → 316)
const TAU_VALUES = [0.1, 0.14, 0.196, 0.274, 0.383, 0.536, 0.75, 1.049, 1.468, 2.054,
                    2.873, 4.019, 5.623, 7.867, 11.007, 15.399, 21.544, 30.142, 42.17, 58.997,
                    82.54, 115.478, 161.56, 226.03, 316.228];

// ────────────────────────────────────────────────────────────────────────────
// State
// ────────────────────────────────────────────────────────────────────────────

let DATA = null;
let currentStrategy = "tau";
let currentAlpha    = 10;  // index into ALPHA_STEPS (0.50 = balanced)
let currentTau      = 12;  // index into TAU_VALUES (~5.62 = middle)
let currentColor    = "base_spirit";
let showLabels      = false;
let highlightFamilies = new Set(["sour", "spirit_forward", "built", "other"]);
let pinnedTooltip   = false;
let pinnedName      = null;

// Ingredient filtering
// Set of ingredient names the user has checked (i.e. "I have this")
// null = not yet initialised (before data loads)
let checkedIngredients = null;

// ────────────────────────────────────────────────────────────────────────────
// SVG setup
// ────────────────────────────────────────────────────────────────────────────

const svg    = d3.select("#scatter");
const gMain  = svg.append("g").attr("class", "main-g");
const gLines  = gMain.append("g").attr("class", "lines-g");   // leader lines — below dots
const gDots   = gMain.append("g").attr("class", "dots-g");
const gLabels = gMain.append("g").attr("class", "labels-g");  // labels — above dots

const margin = { top: 30, right: 30, bottom: 30, left: 30 };
let width, height, xScale, yScale;

function resize() {
  const el = document.getElementById("chart");
  width  = el.clientWidth  - margin.left - margin.right;
  height = el.clientHeight - margin.top  - margin.bottom;
  gMain.attr("transform", `translate(${margin.left},${margin.top})`);
  if (DATA) redraw(true);
}

// ────────────────────────────────────────────────────────────────────────────
// Helpers
// ────────────────────────────────────────────────────────────────────────────

function getStrategyKey() {
  if (currentStrategy === "blend_struct") {
    return ALPHA_KEY_MAP[currentAlpha];
  }
  if (currentStrategy === "tau") {
    return String(TAU_VALUES[currentTau]);
  }
  return currentStrategy;
}

function getPoints() {
  const key = getStrategyKey();
  if (currentStrategy === "tau") {
    return DATA.strategies.tau[key].embedding;
  }
  return DATA.strategies[key].points;
}

function getNeighbors(name) {
  const key = getStrategyKey();
  if (currentStrategy === "tau") {
    // Tau strategies don't have precomputed neighbors
    return [];
  }
  return (DATA.strategies[key].neighbors || {})[name] || [];
}

function dominantFlavor(recipe) {
  const v = recipe.flavor_vector;
  if (!v) return "other";
  const FLAVOR_DIMS = ["sweet","bitter","saline","acid","herbal","spice","citrus","floral","fruit","smoke","oak","grain","vegetal","nutty","anise"];
  const TRACKED = ["sweet","bitter","herbal","citrus","fruit","spice"];
  let best = "other", bestVal = -Infinity;
  TRACKED.forEach((d, _) => {
    const idx = FLAVOR_DIMS.indexOf(d);
    if (idx >= 0 && v[idx] > bestVal) { bestVal = v[idx]; best = d; }
  });
  return bestVal > 0 ? best : "other";
}

// Returns true if all required ingredients for a recipe are checked.
// Garnishes are ignored (they don't gate the drink).
// All components (including null-ml seasonings) must be checked.
function isCocktailMakeable(recipe) {
  if (!checkedIngredients) return true; // before init → show all
  const comps = recipe.components || [];
  for (const c of comps) {
    if (!checkedIngredients.has(c.ingredient)) return false;
  }
  return true;
}

function getColorValue(name, recipe) {
  const fv = recipe.flavor_vector || [];
  const FLAVOR_DIMS = ["sweet","bitter","saline","acid","herbal","spice","citrus","floral","fruit","smoke","oak","grain","vegetal","nutty","anise"];
  const idx = d => FLAVOR_DIMS.indexOf(d);

  switch (currentColor) {
    case "base_spirit":      return recipe.base_spirit;
    case "family":           return recipe.family;
    case "served":           return recipe.served;
    case "dominant_flavor":  return dominantFlavor(recipe);
    case "sweet":            return fv[idx("sweet")] ?? 0;
    case "bitter":           return fv[idx("bitter")] ?? 0;
    case "herbal":           return fv[idx("herbal")] ?? 0;
    case "smoke":            return fv[idx("smoke")] ?? 0;
    case "citrus_acid":      return (fv[idx("citrus")] ?? 0) + (fv[idx("acid")] ?? 0);
    default:                 return 0;
  }
}

function isCategorical(dim) {
  return ["base_spirit","family","served","dominant_flavor"].includes(dim);
}

function colorFor(name, recipe) {
  const val = getColorValue(name, recipe);
  if (isCategorical(currentColor)) {
    const palette = CATEGORICAL_PALETTES[currentColor] || {};
    return palette[val] || "#52525b";
  }
  // Sequential: normalize roughly 0-1
  const norm = currentColor === "citrus_acid" ? Math.min(val / 1.2, 1) : Math.min(val, 1);
  return SEQUENTIAL_COLOR(norm);
}

// ────────────────────────────────────────────────────────────────────────────
// Shape generators
// ────────────────────────────────────────────────────────────────────────────

function dotShape(served) {
  return served === "up"     ? "triangle"
       : served === "on_ice" ? "square"
       :                       "circle";
}

function appendDotShape(sel, r = 8) {
  sel.each(function(d) {
    const shape = dotShape(d.recipe.served);
    const g = d3.select(this);
    if (shape === "circle") {
      g.append("circle").attr("r", r);
    } else if (shape === "square") {
      const s = r * 1.5;
      g.append("rect").attr("x", -s/2).attr("y", -s/2).attr("width", s).attr("height", s).attr("rx", 1);
    } else {
      // inverted triangle (martini glass silhouette)
      const pts = `0,${r} ${-r*0.9},${-r*0.7} ${r*0.9},${-r*0.7}`;
      g.append("polygon").attr("points", pts);
    }
  });
}

// ────────────────────────────────────────────────────────────────────────────
// Main draw / redraw
// ────────────────────────────────────────────────────────────────────────────

function buildScales(points) {
  const xs = Object.values(points).map(p => p.x);
  const ys = Object.values(points).map(p => p.y);
  const xExt = d3.extent(xs);
  const yExt = d3.extent(ys);
  const padX = (xExt[1] - xExt[0]) * 0.1;
  const padY = (yExt[1] - yExt[0]) * 0.1;
  xScale = d3.scaleLinear().domain([xExt[0]-padX, xExt[1]+padX]).range([0, width]);
  yScale = d3.scaleLinear().domain([yExt[0]-padY, yExt[1]+padY]).range([height, 0]);
}

function dotData(points) {
  return Object.entries(points).map(([name, pt]) => ({
    name,
    x: pt.x,
    y: pt.y,
    recipe: DATA.recipes[name] || {},
  }));
}

function redraw(animate = false) {
  const points = getPoints();
  buildScales(points);

  const data = dotData(points);
  const dur   = animate ? 500 : 0;

  // ── Dots ────────────────────────────────────────────────────────────────
  const dotSel = gDots.selectAll(".dot-g")
    .data(data, d => d.name);

  // ENTER
  const enter = dotSel.enter()
    .append("g")
    .attr("class", "dot-g dot")
    .attr("transform", d => `translate(${xScale(d.x)},${yScale(d.y)})`)
    .on("mouseover", onMouseover)
    .on("mouseout",  onMouseout)
    .on("click",     onClick);

  appendDotShape(enter);

  // UPDATE (shape already exists)
  const all = enter.merge(dotSel);

  // Color & opacity (instant)
  all.selectAll("circle,rect,polygon")
    .attr("fill", d => colorFor(d.name, d.recipe))
    .attr("fill-opacity", 0.9)
    .attr("stroke", "#0f0f12")
    .attr("stroke-width", 0.5);

  // Dim non-highlighted families OR unmakeable cocktails
  all.classed("dimmed", d =>
    !highlightFamilies.has(d.recipe.family) || !isCocktailMakeable(d.recipe)
  );

  // Transition position
  if (animate) {
    all.transition().duration(dur).ease(d3.easeCubicInOut)
      .attr("transform", d => `translate(${xScale(d.x)},${yScale(d.y)})`);
  } else {
    all.attr("transform", d => `translate(${xScale(d.x)},${yScale(d.y)})`);
  }

  dotSel.exit().remove();

  // ── Labels + leader lines ────────────────────────────────────────────────
  if (showLabels) {
    drawLabels(data);
  } else {
    gLabels.selectAll(".dot-label").remove();
    gLines.selectAll(".label-line").remove();
  }
}

// ── Label force simulation ───────────────────────────────────────────────────
let labelSimulation = null;

function drawLabels(data) {
  // Each node: dot position (fx/fy fixed) + floating label position (x/y)
  const nodes = data.map(d => ({
    name:    d.name,
    recipe:  d.recipe,
    dotX:    xScale(d.x),   // fixed dot position
    dotY:    yScale(d.y),
    x:       xScale(d.x),   // label starts at dot, then floats
    y:       yScale(d.y),
  }));

  // Stop any previous simulation
  if (labelSimulation) labelSimulation.stop();

  // ── Text elements ──────────────────────────────────────────────────────
  const textSel = gLabels.selectAll(".dot-label")
    .data(nodes, d => d.name);

  textSel.exit().remove();

  const textEnter = textSel.enter()
    .append("text")
    .attr("class", "dot-label")
    .attr("text-anchor", "middle")
    .text(d => d.name.replace(/_/g, " "));

  const texts = textEnter.merge(textSel)
    .classed("dimmed", d => !highlightFamilies.has(d.recipe.family) || !isCocktailMakeable(d.recipe));

  // ── Line elements ──────────────────────────────────────────────────────
  const lineSel = gLines.selectAll(".label-line")
    .data(nodes, d => d.name);

  lineSel.exit().remove();

  const lineEnter = lineSel.enter()
    .append("line")
    .attr("class", "label-line");

  const lines = lineEnter.merge(lineSel)
    .classed("dimmed", d => !highlightFamilies.has(d.recipe.family) || !isCocktailMakeable(d.recipe));

  // Approximate text half-width for collision radius (chars × ~3.5px at 10px font)
  const collideR = d => (d.name.length * 3.5) / 2 + 4;

  labelSimulation = d3.forceSimulation(nodes)
    .force("collide", d3.forceCollide().radius(collideR).strength(0.8).iterations(3))
    // Spring each label back toward its dot
    .force("x", d3.forceX(d => d.dotX).strength(0.12))
    .force("y", d3.forceY(d => d.dotY).strength(0.12))
    .alphaDecay(0.03)
    .on("tick", () => {
      texts
        .attr("x", d => d.x)
        .attr("y", d => d.y);

      lines
        .attr("x1", d => d.dotX)
        .attr("y1", d => d.dotY)
        .attr("x2", d => d.x)
        .attr("y2", d => d.y)
        // Hide line when label is very close to dot
        .attr("visibility", d => {
          const dx = d.x - d.dotX, dy = d.y - d.dotY;
          return Math.sqrt(dx*dx + dy*dy) < 6 ? "hidden" : "visible";
        });
    });
}

// ────────────────────────────────────────────────────────────────────────────
// Tooltip
// ────────────────────────────────────────────────────────────────────────────

const tooltip    = document.getElementById("tooltip");
const ttName     = document.getElementById("tt-name");
const ttMeta     = document.getElementById("tt-meta");
const ttComps    = document.getElementById("tt-components");
const ttGarnish  = document.getElementById("tt-garnish");
const ttNeighbors = document.getElementById("tt-neighbors");

function showTooltip(name, recipe, event) {
  ttName.textContent = name.replace(/_/g, " ").toUpperCase();
  ttMeta.textContent = `${recipe.method} · served ${(recipe.served||"").replace(/_/," ")}`;

  // Components table
  ttComps.innerHTML = "";
  const liqComps = (recipe.components || []).filter(c => c.ml !== null);
  const seasonings = (recipe.components || []).filter(c => c.ml === null);
  const totalMl = liqComps.reduce((s, c) => s + c.ml, 0);

  [...liqComps, ...seasonings].forEach(c => {
    const tr = document.createElement("tr");
    const pct = c.ml !== null ? `${Math.round(c.ml / totalMl * 100)}%` : "—";
    tr.innerHTML = `<td>${c.ingredient.replace(/_/g," ")}</td><td>${c.role}</td><td>${c.ml !== null ? c.ml+"ml" : "—"} ${pct}</td>`;
    ttComps.appendChild(tr);
  });

  // Garnish
  const garnish = recipe.garnish || [];
  ttGarnish.textContent = garnish.length ? `Garnish: ${garnish.map(g=>g.replace(/_/g," ")).join(", ")}` : "";

  // Nearest neighbors
  const nn = getNeighbors(name);
  ttNeighbors.innerHTML = nn.map(n =>
    `<div class="tt-nn-row">
      <span class="tt-nn-name">${n.name.replace(/_/g," ")}</span>
      <span class="tt-nn-dist">${n.distance.toFixed(3)}</span>
    </div>`
  ).join("");

  // Position tooltip (keep it in viewport)
  const chartRect = document.getElementById("chart").getBoundingClientRect();
  let x = event.clientX - chartRect.left + 16;
  let y = event.clientY - chartRect.top  + 16;
  const tw = 300, th = 320;
  if (x + tw > chartRect.width)  x = event.clientX - chartRect.left - tw - 16;
  if (y + th > chartRect.height) y = event.clientY - chartRect.top  - th - 16;
  tooltip.style.transform = `translate(${x}px, ${y}px)`;

  tooltip.classList.add("visible");
}

function hideTooltip() {
  if (!pinnedTooltip) tooltip.classList.remove("visible");
}

function onMouseover(event, d) {
  if (pinnedTooltip && pinnedName !== d.name) return;
  showTooltip(d.name, d.recipe, event);
}

function onMouseout() {
  if (!pinnedTooltip) hideTooltip();
}

function onClick(event, d) {
  event.stopPropagation();
  if (pinnedTooltip && pinnedName === d.name) {
    // Unpin
    pinnedTooltip = false;
    pinnedName    = null;
    tooltip.classList.remove("pinned");
    tooltip.classList.remove("visible");
  } else {
    pinnedTooltip = true;
    pinnedName    = d.name;
    tooltip.classList.add("pinned");
    showTooltip(d.name, d.recipe, event);
  }
}

document.getElementById("tt-close").addEventListener("click", () => {
  pinnedTooltip = false;
  pinnedName    = null;
  tooltip.classList.remove("pinned", "visible");
});

document.addEventListener("keydown", e => {
  if (e.key === "Escape") {
    pinnedTooltip = false;
    pinnedName    = null;
    tooltip.classList.remove("pinned", "visible");
  }
});

svg.on("click", () => {
  if (pinnedTooltip) {
    pinnedTooltip = false;
    pinnedName    = null;
    tooltip.classList.remove("pinned", "visible");
  }
});

// ────────────────────────────────────────────────────────────────────────────
// Legend
// ────────────────────────────────────────────────────────────────────────────

function updateLegend() {
  const container = document.getElementById("legend-items");
  container.innerHTML = "";

  if (isCategorical(currentColor)) {
    const palette = CATEGORICAL_PALETTES[currentColor] || {};
    Object.entries(palette).forEach(([key, color]) => {
      const row = document.createElement("div");
      row.className = "legend-row";
      row.innerHTML = `<div class="legend-swatch" style="background:${color}"></div><span>${key.replace(/_/g," ")}</span>`;
      container.appendChild(row);
    });
  } else {
    // Sequential gradient
    const grad = document.createElement("div");
    grad.style.cssText = `width:100%;height:10px;border-radius:4px;background:linear-gradient(to right,${
      d3.range(0, 1.01, 0.1).map(t => SEQUENTIAL_COLOR(t)).join(",")
    });margin-bottom:4px;`;
    const labels = document.createElement("div");
    labels.style.cssText = "display:flex;justify-content:space-between;font-size:10px;color:#52525b;";
    labels.innerHTML = "<span>low</span><span>high</span>";
    container.appendChild(grad);
    container.appendChild(labels);
  }
}

// ────────────────────────────────────────────────────────────────────────────
// Explanation panel
// ────────────────────────────────────────────────────────────────────────────

function updateExplanation() {
  document.getElementById("explanation").innerHTML = STRATEGY_EXPLANATIONS[currentStrategy] || "";
}

// ────────────────────────────────────────────────────────────────────────────
// Bottom panel toggle
// ────────────────────────────────────────────────────────────────────────────

document.getElementById("bottom-panel-toggle").addEventListener("click", () => {
  document.getElementById("bottom-panel").classList.toggle("collapsed");
});

// ────────────────────────────────────────────────────────────────────────────
// Controls wiring
// ────────────────────────────────────────────────────────────────────────────

// Strategy radio
document.getElementById("strategy-group").addEventListener("click", e => {
  const label = e.target.closest(".strategy-btn");
  if (!label) return;
  const strategy = label.dataset.strategy;
  if (!strategy || strategy === currentStrategy) return;

  // Update radio + active class
  document.querySelectorAll(".strategy-btn").forEach(l => l.classList.remove("active"));
  label.classList.add("active");
  label.querySelector("input").checked = true;
  currentStrategy = strategy;

  // Slide open/closed the relevant slider drawer
  document.getElementById("alpha-row").classList.toggle("open", strategy === "blend_struct");
  document.getElementById("tau-row").classList.toggle("open", strategy === "tau");

  updateExplanation();
  if (DATA) redraw(true);
});

// α slider
function setAlpha(idx) {
  currentAlpha = Math.max(0, Math.min(20, idx));
  document.getElementById("alpha-slider").value = currentAlpha;
  const alpha = ALPHA_STEPS[currentAlpha];
  document.getElementById("alpha-value").textContent =
    `α = ${alpha.toFixed(2)} (${alpha === 0.5 ? "balanced" : alpha < 0.5 ? "more structure" : "more flavor"})`;
  if (DATA && currentStrategy === "blend_struct") redraw(true);
}

document.getElementById("alpha-slider").addEventListener("input", e => setAlpha(parseInt(e.target.value)));
document.getElementById("alpha-dec").addEventListener("click", () => setAlpha(currentAlpha - 1));
document.getElementById("alpha-inc").addEventListener("click", () => setAlpha(currentAlpha + 1));

// τ slider
function setTau(idx) {
  currentTau = Math.max(0, Math.min(24, idx));
  document.getElementById("tau-slider").value = currentTau;
  const tau = TAU_VALUES[currentTau];
  const description = tau < 0.5 ? "intensity-dominated" : tau < 3 ? "intense + volume" : tau < 30 ? "balanced" : tau < 100 ? "volume-dominated" : "≈ Flavor Blend";
  document.getElementById("tau-value").textContent = `τ = ${tau < 10 ? tau.toFixed(2) : tau.toFixed(0)} (${description})`;
  if (DATA && currentStrategy === "tau") redraw(true);
}

document.getElementById("tau-slider").addEventListener("input", e => setTau(parseInt(e.target.value)));
document.getElementById("tau-dec").addEventListener("click", () => setTau(currentTau - 1));
document.getElementById("tau-inc").addEventListener("click", () => setTau(currentTau + 1));

// Color by
document.getElementById("color-select").addEventListener("change", e => {
  currentColor = e.target.value;
  updateLegend();
  if (DATA) redraw(false);
});

// Show labels
document.getElementById("show-labels").addEventListener("change", e => {
  showLabels = e.target.checked;
  if (DATA) redraw(false);
});

// Family checkboxes
document.querySelectorAll(".family-cb").forEach(cb => {
  cb.addEventListener("change", () => {
    highlightFamilies = new Set(
      [...document.querySelectorAll(".family-cb:checked")].map(c => c.value)
    );
    if (DATA) redraw(false);
  });
});

// Resize
window.addEventListener("resize", resize);

// ────────────────────────────────────────────────────────────────────────────
// Zoom & pan
// ────────────────────────────────────────────────────────────────────────────

let currentTransform = d3.zoomIdentity;

const zoom = d3.zoom()
  .scaleExtent([0.5, 15])
  .on("zoom", e => {
    currentTransform = e.transform;
    gMain.attr("transform", e.transform);
    // Re-run label simulation with updated dot positions if labels are visible
    if (showLabels && DATA) {
      drawLabels(dotData(getPoints()));
    }
  });

svg.call(zoom);

// ────────────────────────────────────────────────────────────────────────────
// Resizable sidebar
// ────────────────────────────────────────────────────────────────────────────

(function() {
  const handle  = document.getElementById("resize-handle");
  const sidebar = document.getElementById("sidebar");
  let dragging  = false;
  let startX    = 0;
  let startW    = 0;

  handle.addEventListener("mousedown", e => {
    dragging = true;
    startX   = e.clientX;
    startW   = sidebar.getBoundingClientRect().width;
    handle.classList.add("dragging");
    // Prevent text selection while dragging
    document.body.style.userSelect = "none";
    document.body.style.cursor = "col-resize";
    e.preventDefault();
  });

  document.addEventListener("mousemove", e => {
    if (!dragging) return;
    const delta  = e.clientX - startX;
    const newW   = Math.min(520, Math.max(180, startW + delta));
    sidebar.style.width = newW + "px";
    resize(); // recompute chart scales
  });

  document.addEventListener("mouseup", () => {
    if (!dragging) return;
    dragging = false;
    handle.classList.remove("dragging");
    document.body.style.userSelect = "";
    document.body.style.cursor = "";
  });
})();

// ────────────────────────────────────────────────────────────────────────────
// Ingredient Panel
// ────────────────────────────────────────────────────────────────────────────

// Group display names
const GROUP_LABELS = {
  spirit:          "Spirits",
  vermouth:        "Vermouth & Fortified",
  amaro:           "Amaro & Aperitivo",
  herbal_liqueur:  "Herbal Liqueurs",
  fruit_liqueur:   "Fruit Liqueurs",
  sweetener:       "Sweeteners & Syrups",
  citrus:          "Citrus & Juice",
  bitters:         "Bitters",
  other:           "Other",
  sparkling:       "Sparkling",
  mixer:           "Mixers",
  _ungrouped:      "Uncategorised",
};

// Subgroup labels within spirits
const SUBGROUP_LABELS = {
  whiskey: "Whiskey",
  gin:     "Gin",
  agave:   "Agave",
  rum:     "Rum",
  brandy:  "Brandy",
  vodka:   "Vodka",
};

// Pretty-print an ingredient name
function prettyName(s) {
  return s.replace(/_/g, " ").replace(/\b\w/g, c => c.toUpperCase());
}

// Build the flat set of all ingredients used in any recipe
function getAllRecipeIngredients(recipes) {
  const used = new Set();
  for (const recipe of Object.values(recipes)) {
    for (const c of (recipe.components || [])) {
      used.add(c.ingredient);
    }
    // Garnishes deliberately excluded — they don't block making the drink
  }
  return used;
}

// Update the count badge
function updateIngredientCount() {
  const recipes = Object.values(DATA.recipes);
  const total   = recipes.length;
  const makeable = recipes.filter(r => isCocktailMakeable(r)).length;
  const el = document.getElementById("ingredient-count");
  if (makeable === total) {
    el.textContent = "All cocktails shown";
  } else {
    el.textContent = `${makeable} of ${total} cocktails makeable`;
  }
}

function buildIngredientPanel() {
  const taxonomy = DATA.taxonomy; // we'll load this separately or inline from embeddings
  const usedIngredients = getAllRecipeIngredients(DATA.recipes);

  // Initialise checkedIngredients to ALL used ingredients (all checked by default)
  checkedIngredients = new Set(usedIngredients);

  const body = document.getElementById("ingredient-panel-body");
  body.innerHTML = "";

  // We'll iterate groups in a preferred order
  const GROUP_ORDER = [
    "spirit", "vermouth", "amaro", "herbal_liqueur", "fruit_liqueur",
    "sweetener", "citrus", "bitters", "other", "sparkling", "mixer"
    // "garnish" is intentionally omitted
  ];

  // Track which ingredients have been placed into a group
  const placedIngredients = new Set();

  for (const groupKey of GROUP_ORDER) {
    const groupDef = DATA.taxonomy[groupKey];
    if (!groupDef) continue;

    // Collect all leaves in this group
    const allLeavesInGroup = [];
    // Check if group has subgroups (depth 2) or is flat (depth 1)
    const hasSubgroups = Object.values(groupDef).some(v => v !== null && typeof v === "object");

    if (hasSubgroups) {
      for (const sub of Object.values(groupDef)) {
        if (sub && typeof sub === "object") {
          for (const leaf of Object.keys(sub)) allLeavesInGroup.push(leaf);
        }
      }
    } else {
      allLeavesInGroup.push(...Object.keys(groupDef));
    }

    // Only show ingredients that are actually used in recipes
    const usedInGroup = allLeavesInGroup.filter(i => usedIngredients.has(i));
    if (usedInGroup.length === 0) continue;

    // Mark these as placed
    usedInGroup.forEach(i => placedIngredients.add(i));

    // ── Group container ────────────────────────────────────────────────
    const groupDiv = document.createElement("div");
    groupDiv.className = "ing-group";
    groupDiv.dataset.group = groupKey;

    // Header row (click to collapse/expand)
    const header = document.createElement("div");
    header.className = "ing-group-header";
    header.innerHTML = `
      <span class="ing-group-title">
        <span class="ing-group-chevron">▼</span>
        ${GROUP_LABELS[groupKey] || prettyName(groupKey)}
      </span>
      <span class="ing-group-actions">
        <button class="ing-group-toggle" data-action="all">all</button>
        <button class="ing-group-toggle" data-action="none">none</button>
      </span>`;

    header.querySelector(".ing-group-title").addEventListener("click", () => {
      groupDiv.classList.toggle("collapsed");
    });

    // "all" / "none" buttons
    header.querySelector("[data-action='all']").addEventListener("click", e => {
      e.stopPropagation();
      groupDiv.querySelectorAll(".ing-item input[type='checkbox']").forEach(cb => {
        cb.checked = true;
        checkedIngredients.add(cb.value);
      });
      onIngredientChange();
    });
    header.querySelector("[data-action='none']").addEventListener("click", e => {
      e.stopPropagation();
      groupDiv.querySelectorAll(".ing-item input[type='checkbox']").forEach(cb => {
        cb.checked = false;
        checkedIngredients.delete(cb.value);
      });
      onIngredientChange();
    });

    groupDiv.appendChild(header);

    // Items container
    const itemsDiv = document.createElement("div");
    itemsDiv.className = "ing-group-items";

    if (hasSubgroups) {
      // Render with subgroup dividers
      for (const [subKey, subDef] of Object.entries(groupDef)) {
        if (!subDef || typeof subDef !== "object") continue;
        const subLeaves = Object.keys(subDef).filter(i => usedIngredients.has(i));
        if (subLeaves.length === 0) continue;

        const subLabel = document.createElement("div");
        subLabel.className = "ing-subgroup-label";
        subLabel.textContent = SUBGROUP_LABELS[subKey] || prettyName(subKey);
        itemsDiv.appendChild(subLabel);

        for (const ing of subLeaves) {
          itemsDiv.appendChild(makeIngredientItem(ing));
        }
      }
    } else {
      for (const ing of usedInGroup) {
        itemsDiv.appendChild(makeIngredientItem(ing));
      }
    }

    groupDiv.appendChild(itemsDiv);
    body.appendChild(groupDiv);
  }

  // ── Fallback: any recipe ingredient not found in taxonomy ───────────────
  const ungrouped = [...usedIngredients].filter(i => !placedIngredients.has(i)).sort();
  if (ungrouped.length > 0) {
    const groupDiv = document.createElement("div");
    groupDiv.className = "ing-group";
    groupDiv.dataset.group = "_ungrouped";

    const header = document.createElement("div");
    header.className = "ing-group-header";
    header.innerHTML = `
      <span class="ing-group-title">
        <span class="ing-group-chevron">▼</span>
        ${GROUP_LABELS._ungrouped}
      </span>
      <span class="ing-group-actions">
        <button class="ing-group-toggle" data-action="all">all</button>
        <button class="ing-group-toggle" data-action="none">none</button>
      </span>`;

    header.querySelector(".ing-group-title").addEventListener("click", () => {
      groupDiv.classList.toggle("collapsed");
    });
    header.querySelector("[data-action='all']").addEventListener("click", e => {
      e.stopPropagation();
      groupDiv.querySelectorAll(".ing-item input[type='checkbox']").forEach(cb => {
        cb.checked = true; checkedIngredients.add(cb.value);
      });
      onIngredientChange();
    });
    header.querySelector("[data-action='none']").addEventListener("click", e => {
      e.stopPropagation();
      groupDiv.querySelectorAll(".ing-item input[type='checkbox']").forEach(cb => {
        cb.checked = false; checkedIngredients.delete(cb.value);
      });
      onIngredientChange();
    });

    groupDiv.appendChild(header);
    const itemsDiv = document.createElement("div");
    itemsDiv.className = "ing-group-items";
    for (const ing of ungrouped) itemsDiv.appendChild(makeIngredientItem(ing));
    groupDiv.appendChild(itemsDiv);
    body.appendChild(groupDiv);
  }
}

function makeIngredientItem(ing) {
  const label = document.createElement("label");
  label.className = "ing-item";
  label.title = ing.replace(/_/g, " ");

  const cb = document.createElement("input");
  cb.type    = "checkbox";
  cb.value   = ing;
  cb.checked = true; // all checked by default

  cb.addEventListener("change", () => {
    if (cb.checked) {
      checkedIngredients.add(ing);
    } else {
      checkedIngredients.delete(ing);
    }
    onIngredientChange();
  });

  const span = document.createElement("span");
  span.textContent = prettyName(ing);

  label.appendChild(cb);
  label.appendChild(span);
  return label;
}

function onIngredientChange() {
  updateIngredientCount();
  if (DATA) redraw(false);
}

// ────────────────────────────────────────────────────────────────────────────
// Right resize handle
// ────────────────────────────────────────────────────────────────────────────

(function() {
  const handle = document.getElementById("right-resize-handle");
  const panel  = document.getElementById("ingredient-panel");
  let dragging = false;
  let startX   = 0;
  let startW   = 0;

  handle.addEventListener("mousedown", e => {
    dragging = true;
    startX   = e.clientX;
    startW   = panel.getBoundingClientRect().width;
    handle.classList.add("dragging");
    document.body.style.userSelect = "none";
    document.body.style.cursor = "col-resize";
    e.preventDefault();
  });

  document.addEventListener("mousemove", e => {
    if (!dragging) return;
    // Dragging left increases panel width (panel is on the right)
    const delta = startX - e.clientX;
    const newW  = Math.min(400, Math.max(160, startW + delta));
    panel.style.width = newW + "px";
    resize();
  });

  document.addEventListener("mouseup", () => {
    if (!dragging) return;
    dragging = false;
    handle.classList.remove("dragging");
    document.body.style.userSelect = "";
    document.body.style.cursor = "";
  });
})();

// ────────────────────────────────────────────────────────────────────────────
// Fetch & init
// ────────────────────────────────────────────────────────────────────────────

d3.json("data/embeddings.json").then(data => {
  DATA = data;
  document.getElementById("loading").style.display = "none";

  // We also need the taxonomy to build the ingredient panel
  return d3.json("data/taxonomy.json").then(taxonomy => {
    DATA.taxonomy = taxonomy;
    resize();
    updateExplanation();
    updateLegend();
    buildIngredientPanel();
    updateIngredientCount();
  });
}).catch(err => {
  document.getElementById("loading").textContent = `Failed to load embeddings.json: ${err.message}`;
  console.error(err);
});
</script>
</body>
</html>
