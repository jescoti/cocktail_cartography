# Cocktail Clustering & Visualization — Implementation Spec

## What exists today

```
cocktail_cartography/
├── data/
│   ├── ingredients.xlsx    ← source of truth, edited by hand
│   ├── ingredients.csv     ← generated by scripts/export_ingredients.py
│   ├── recipes.json        ← 100 cocktail recipes
│   └── taxonomy.json       ← ingredient category tree
├── scripts/
│   └── export_ingredients.py
├── loaders.py              ← reads data/ into Python dicts: FLAVOR_DIMS, INGREDIENTS, RECIPES, CATEGORY_TREE
├── utils.py                ← distance functions
└── __main__.py             ← validation / sanity-check printout
```

### Flavor dimensions (15, from CSV header)
`sweet, bitter, saline, acid, herbal, spice, citrus, floral, fruit, smoke, oak, grain, vegetal, nutty, anise`

### Recipe data model (from recipes.json)
Each recipe has:
- `method`: `stirred | built | shaken`
- `served`: `up | on_ice | either`
- `components`: list of `{ingredient, role, ml}` where `ml` is `null` for seasonings
  - roles: `base | modifier | citrus | sweetener | accent | seasoning`
- `garnish`: list of ingredient names

### Existing utility functions (utils.py)
- `get_flavor_vector(name)` → np.ndarray (15-dim)
- `recipe_flavor_vector(name)` → proportion-weighted blend of component vectors (current approach)
- `recipe_structural_vector(name)` → dict of method, served, role proportions
- `recipe_distance(a, b, alpha, beta)` → scalar combining flavor + structural cosine distance

---

## Phase 1: cluster.py — compute embeddings and export JSON

New file. Takes all recipes, computes a cocktail vector under one or more vectorization strategies, runs UMAP to 2D, and writes `data/embeddings.json`.

Run with: `python scripts/build_embeddings.py`

### 1A. The central design question: how do you turn a recipe into a vector?

The key insight is that the **ingredient flavor profiles are hand-authored embeddings** — they represent expert knowledge about how things taste. The question is how to combine them into a single cocktail vector. Several strategies have meaningfully different properties. The viz will expose all of them.

#### Strategy 1: Proportion-weighted blend (BLEND)
Sum ingredient flavor vectors weighted by their fraction of total volume. Seasonings get a fixed weight of 0.05, garnishes 0.03.

```
v_cocktail = Σ (ml_i / total_ml) * v_ingredient_i   [for liquid components]
           + Σ 0.05 * v_ingredient_i                  [for seasonings]
           + Σ 0.03 * v_ingredient_i                  [for garnishes]
```

Result: 15-dimensional vector. Pure flavor blend — structure is invisible.

**Strength**: captures the overall taste. A Negroni and a Bijou will be close because they're both bitter+herbal+sweet.
**Weakness**: loses structure entirely. A Manhattan and a Bee's Knees could look similar if their blended flavors happen to converge. Has no sense of "this has citrus in it at all."

---

#### Strategy 2: Blend + structural append (BLEND+STRUCT)
Concatenate the 15-dim flavor blend with a structural vector encoding role proportions and serving:

```
structural = [
  prop_base,        # fraction of volume that is "base"
  prop_modifying,   # modifier + sweetener merged (same structural role)
  prop_citrus,      # fraction that is citrus
  prop_accent,      # fraction that is accent
  has_seasoning,    # 0 or 1
  is_up,            # 0 or 1
  is_on_ice,        # 0 or 1
]
```

Result: 22-dimensional vector. The relative weighting of flavor vs. structure is controlled by scaling these two halves — which becomes the α/β parameter in the UI.

**Strength**: captures both. Two drinks are close only if they taste similar AND have a similar structure (how much spirit, how much modifier, etc.).
**Weakness**: α/β weighting is somewhat arbitrary. Currently this is a knob that needs tuning.

---

#### Strategy 3: Role-slot flavor vectors (ROLE-SLOT)
Instead of blending everything together, build a fixed vector that's the flavor profile of each structural slot. The cocktail is represented as:

```
v_cocktail = [v_base | v_modifying | v_citrus | v_accent]
```

where each slot is the **volume-weighted average** of all ingredients in that role, and zero-padded if the slot is empty. Seasonings contribute a small fixed amount distributed across all slots. Garnish flavor is added to accent.

Result: 4 × 15 = 60 dimensions.

**Strength**: most structurally meaningful. A Manhattan and a Bijou are close because their *base slots* taste similar (whiskey ≈ gin in some dimensions) AND their *modifier slots* taste similar (sweet vermouth). A Manhattan and a Daiquiri are far because one has no citrus slot and the other has no modifying slot.
**Weakness**: harder to reason about. Drinks with unusual role distributions (Vieux Carré has two bases) need careful handling. Empty slots create sparsity.

---

#### Strategy 4: Perceptual / nonlinear blend (PERCEPTUAL)
Motivated by the observation that some ingredients "punch above their weight" — a small amount of Fernet-Branca, Chartreuse, Benedictine, or Mezcal dominates the drink's character regardless of proportion. Model this with a nonlinear aggregation:

For each flavor dimension d:
```
v_d = max(v_ingredients_d) * punch_weight
    + proportion_weighted_blend_d * (1 - punch_weight)
```

where `punch_weight` is a parameter (e.g. 0.4) controlling how much the max-contributing ingredient matters vs. the weighted average. In practice this means: if you have 7.5ml of Chartreuse in a drink, its herbal character will contribute disproportionately to the cocktail's herbal dimension.

Result: 15-dimensional vector, same shape as BLEND.

**Strength**: matches how people actually taste cocktails. The accent/modifier with a strong personality registers clearly. Explains why the Hanky Panky tastes like Fernet even though it's only 8% of volume.
**Weakness**: the `punch_weight` parameter is a guess. Doesn't explicitly model structure.

---

### 1B. UMAP embedding

For each strategy, run UMAP with:
- `n_components=2`
- `metric='cosine'` (since vectors are flavor intensities, not positions)
- `n_neighbors=10` (tunable in UI via re-build, or pre-bake a few values)
- `min_dist=0.1`

The result is a 2D (x, y) position per cocktail for each strategy.

### 1C. Output format: data/embeddings.json

```json
{
  "strategies": {
    "blend": {
      "description": "Proportion-weighted flavor blend. Pure taste, no structure.",
      "points": {
        "manhattan": {"x": 0.42, "y": -1.1},
        "last_word":  {"x": 2.1,  "y": 0.8},
        ...
      }
    },
    "blend_struct": { ... },
    "role_slot":    { ... },
    "perceptual":   { ... }
  },
  "recipes": {
    "manhattan": {
      "method": "stirred",
      "served": "up",
      "components": [...],
      "garnish": [...],
      "base_spirit": "whiskey",
      "family": "spirit_forward",
      "flavor_vector": [0.3, 0.5, ...]
    },
    ...
  }
}
```

The `base_spirit` and `family` fields are derived automatically:
- `base_spirit`: the taxonomy top-level category (`spirit|whiskey|...` → `"whiskey"`) of whichever ingredient has role=`base` and the most volume. If multiple different spirit types, use `"mixed"`.
- `family`: derived from role structure:
  - has `citrus` role → `"sour"`
  - no citrus, `served=on_ice`, no modifier → `"built"`
  - no citrus, has `modifier` → `"spirit_forward"`
  - fallback: `"other"`

---

## Phase 2: viz/index.html — interactive scatter plot

Single self-contained HTML file. Data is fetched from `../data/embeddings.json` (relative path, works with `python -m http.server` from project root). Uses D3.js v7 from CDN. No build step.

Run with:
```
python -m http.server 8000
# open http://localhost:8000/viz/
```

### 2A. Dot encoding

| Property | Encoding |
|---|---|
| Position | UMAP x, y from selected strategy |
| Shape | serving style: ▽ inverted triangle = up, ■ square = on_ice, ● circle = either |
| Color | selected color dimension (see 2B) |
| Size | fixed, slightly larger on hover |

SVG shapes:
- `up` → `<polygon points="0,-10 -9,8 9,8">` (inverted triangle, martini glass silhouette)
- `on_ice` → `<rect x="-7" y="-7" width="14" height="14">`
- `either` → `<circle r="7">`

### 2B. Color dimensions (dropdown)

All use a categorical or sequential color scale as appropriate.

| Option | What it shows | Scale |
|---|---|---|
| **Base spirit** | Taxonomy top-level of base ingredient: whiskey, gin, rum, tequila/agave, brandy, mixed | Categorical (6 colors) |
| **Family** | sour / spirit_forward / built / other | Categorical (4 colors) |
| **Served** | up / on_ice / either | Categorical (3 colors) — mostly redundant with shape, but useful as a check |
| **Dominant flavor** | Whichever of {sweet, bitter, herbal, citrus, fruit, spice} is highest in the cocktail's blend vector | Categorical |
| **Sweetness** | `sweet` dimension of blended vector | Sequential (low→high) |
| **Bitterness** | `bitter` dimension | Sequential |
| **Herbaceousness** | `herbal` dimension | Sequential |
| **Smoke** | `smoke` dimension | Sequential |
| **Citrus intensity** | `citrus + acid` dimensions summed | Sequential |

### 2C. Controls panel (left sidebar)

**Vectorization strategy** (radio buttons, one at a time):
- ○ Flavor blend — *"What does it taste like overall? Proportion-weighted sum of ingredient flavors."*
- ○ Blend + structure — *"Taste + shape. Adds how much of the drink is base vs. modifier vs. citrus. Use the α/β slider to weight them."*
- ○ Role-slot — *"Structure first. Compares base-to-base, modifier-to-modifier. Two drinks are close only if the same slots taste similar."*
- ○ Perceptual — *"Punchy ingredients win. Small amounts of Chartreuse, Fernet, Mezcal pull their slot's character toward theirs."*

**α/β slider** (only active when Blend+Structure is selected):
- "← More flavor / More structure →"
- Range 0.0–1.0, α = slider value, β = 1 − α
- Changing this triggers a re-fetch of the correct pre-baked layout (see note below)

**Color by** (dropdown, options from 2B)

**Show labels** (toggle): display cocktail names next to dots

**Highlight family** (multi-select checkboxes): dim all dots not in selected families

### 2D. Tooltip (hover)

Appears on mouseover, pinned on click (click again or press Escape to dismiss).

```
MANHATTAN
stirred · served up

  rye whiskey     base       60ml   67%
  sweet vermouth  modifier   30ml   33%
  angostura       seasoning  —

Garnish: cherry

Nearest neighbors:
  0.02  Black Manhattan
  0.08  Rob Roy
  0.12  Bobby Burns
```

Nearest neighbors shown from the currently-selected strategy's distance matrix (pre-computed and stored in embeddings.json).

### 2E. Strategy explanation panel

Below the controls, a text block that changes with the selected strategy, explaining in plain English:
- What the strategy is doing
- What to look for in the resulting clusters
- Known strengths and weaknesses

This is the "interesting discussion" about vector construction for the class.

---

## Phase 3: Pre-baking α/β snapshots

Rather than recomputing UMAP in the browser (not feasible), pre-bake 5 layouts for Blend+Structure at α = 0.0, 0.25, 0.5, 0.75, 1.0. Store all 5 in `embeddings.json` under `"blend_struct_a00"`, `"blend_struct_a25"`, etc. The α/β slider snaps to the nearest pre-baked value and swaps the layout with a smooth D3 transition.

---

## Implementation order

1. **`scripts/build_embeddings.py`**
   - Implement all 4 vectorization strategies as functions
   - Run UMAP on each
   - Derive `base_spirit` and `family` for each recipe
   - Compute pre-baked α/β layouts for blend+struct
   - Compute nearest-neighbor lists (top 5, per strategy) from full distance matrices
   - Write `data/embeddings.json`

2. **`viz/index.html`**
   - Scaffold with D3, fetch embeddings.json
   - Render dots with shape encoding
   - Wire up controls → layout swap with transition
   - Tooltip with recipe detail + nearest neighbors
   - Strategy explanation panel
   - Color scales

3. **Validation / tuning loop**
   - Run `python scripts/build_embeddings.py` after any ingredient CSV change
   - Reload viz in browser
   - Adjust flavor profiles in ingredients.xlsx → re-export → rebuild → reload

---

## Dependencies to add to venv

```
umap-learn
```

Everything else (numpy, openpyxl) is already installed. D3 is loaded from CDN, no install needed.

Install:
```
.venv/bin/pip install umap-learn
```

---

## Open questions / deliberate deferral

- **Perceptual punch_weight**: start at 0.4, expose as a slider in a future iteration
- **UMAP n_neighbors**: start at 10, possibly expose as a control later
- **Hierarchical clustering / dendrogram**: useful but complex; defer until scatter plot is working
- **"Suggest a cocktail given what's on the bar"**: out of scope for this phase
